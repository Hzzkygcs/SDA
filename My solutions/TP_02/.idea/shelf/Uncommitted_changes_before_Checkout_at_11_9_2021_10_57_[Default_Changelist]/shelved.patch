Index: Solusi/src/Solusi.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.io.*;\r\nimport java.util.*;\r\nimport java.util.HashMap;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.function.Consumer;\r\n\r\npublic class Solusi {\r\n    public static long __TESTCASE__ = -1;\r\n    public static PrintWriter out = new PrintWriter(System.out);\r\n//    public static PrintStream out = System.out;  // debug\r\n    public static InputReader in = new InputReader(System.in);\r\n    \r\n    public static HashMap<String, Pulau> pulau_hm = new HashMap<>(100*1000 + 7);\r\n    public static HashMap<String, Kuil> kuil_hm = new HashMap<>(300*1000 + 7);\r\n    \r\n    public static Dataran get_raiden_shogun() {\r\n        return _raiden_shogun;\r\n    }\r\n    \r\n    public static void set_raiden_shogun(Dataran raiden_shogun) {\r\n        _raiden_shogun = raiden_shogun;\r\n    }\r\n    \r\n    public static Dataran _raiden_shogun;\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    public static void debug_print_semua_kuil(){\r\n        Iterator<String> it = kuil_hm.keySet().iterator();\r\n        for (int i = 0; it.hasNext(); i++) {\r\n            String nama_kuil = it.next();\r\n            System.out.printf(\"%s: \\n\", nama_kuil);\r\n            debug_print_kuil(nama_kuil);\r\n        }\r\n    }\r\n    \r\n    public static void debug_print_kuil(String nama){\r\n        Kuil kuil = kuil_hm.get(nama);\r\n        System.out.println(kuil);\r\n        System.out.println(kuil.tree);\r\n        System.out.println();\r\n    }\r\n    \r\n    public static void debug_print_isi_semua_pulau(){\r\n        pulau_hm.forEach((key, value)->{\r\n            System.out.print(value.nama + \":  \");\r\n            value.forEach((kuil_bundel) -> {\r\n                System.out.print(kuil_bundel.data.nama);\r\n                System.out.print(\", \");\r\n            });\r\n            System.out.println();\r\n        });\r\n    }\r\n    \r\n    \r\n    public static void main(String[] args) {\r\n        pulau_hm.clear();\r\n        kuil_hm.clear();\r\n        \r\n        input_pulau_dan_kuil();\r\n        input_informasi_raiden();\r\n        input_query_peperangan();\r\n        out.flush();\r\n    }\r\n    \r\n    \r\n    public static ArrayList<Long> to_be_sorted_arr = new ArrayList<>(400*1000 + 5);\r\n    public static ArrayList<Long> temporary_arr = new ArrayList<>(400*1000 + 5);\r\n    public static ArrayList<Long> original_arr = new ArrayList<>(400*1000 + 5);\r\n    public static HashMap<Long, DataranBstNode> cached_bst_node = new HashMap<>(400*1000 + 7);\r\n    \r\n    public static void input_pulau_dan_kuil(){\r\n        long banyak_pulau = in.nextLong();\r\n        for (int i = 0; i < banyak_pulau; i++) {\r\n            String nama_pulau = in.next();\r\n            long banyak_dataran = in.nextLong();\r\n            to_be_sorted_arr.clear();\r\n            original_arr.clear();\r\n            cached_bst_node.clear();\r\n            temporary_arr.clear();  // clear is optional\r\n        \r\n            Pulau pulau = new Pulau(nama_pulau);\r\n            Kuil kuil = new Kuil(nama_pulau, pulau, null);\r\n    \r\n            long ketinggian;\r\n            \r\n            for (int j = 0; j < banyak_dataran; j++) {\r\n                ketinggian = in.nextLong();\r\n                to_be_sorted_arr.add(ketinggian);\r\n                original_arr.add(ketinggian);\r\n            }\r\n            sortings.merge_sort(to_be_sorted_arr, temporary_arr);\r\n    \r\n            // harus nilai median yang menjadi root data pada BST, supaya kompleksitasnya optimal.\r\n            // - 1 karena menyesuaikan dummy_initial_value yang ada di splitter. Harus sesuai supaya terjadi cache hit\r\n            // pada kuil.cached_reserve. Kalau tidak cache hit, maka cached_bst_node.get(parent) akan bernilai null\r\n            // sehingga program akan crash/error karena null pointer exception\r\n            long median_ketinggian = to_be_sorted_arr.get((to_be_sorted_arr.size() - 1) / 2);\r\n            DataranBstNode first_cache = kuil.reserve_node(median_ketinggian);  // cache initiator\r\n            cached_bst_node.put(median_ketinggian, first_cache);\r\n    \r\n            temporary_arr.clear();\r\n            sortings.splitter_with_parent(to_be_sorted_arr, (index, height, parent) -> {\r\n                DataranBstNode temp = kuil.cached_push_back(height, cached_bst_node.get(parent));\r\n                temporary_arr.add(height);\r\n                cached_bst_node.put(height, temp);\r\n            });\r\n    \r\n            // cached push back needed to optimize this loop from O(N log N) [because of updating its parent\r\n            // height and count] to be O(N)\r\n            for (int j = 0; j < original_arr.size(); j++) {\r\n                long temp_height = original_arr.get(j);\r\n                kuil.cached_push_back(temp_height, cached_bst_node.get(temp_height));  // O(1)\r\n            }\r\n            \r\n            \r\n            \r\n            // O(N) updating its paren't height, because we're updating whole node at once from bottom to top\r\n            while (!temporary_arr.isEmpty()){\r\n                long temp = temporary_arr.remove(temporary_arr.size()-1);\r\n                DataranBstNode dataran = cached_bst_node.get(temp);\r\n                dataran.update_this_height_and_count();  // doesn't update parent. O(1) instead of O(log N)\r\n            }\r\n            \r\n            pulau.add(kuil);\r\n            kuil.__pulau_senarai_bundel = (DataBundel<Kuil>) pulau.tail.prev;\r\n            \r\n            pulau_hm.put(nama_pulau, pulau);\r\n            kuil_hm.put(nama_pulau, kuil);\r\n        }\r\n        debug_print_semua_kuil();\r\n    }\r\n    \r\n    public static void input_informasi_raiden(){\r\n        String pulau_raiden = in.next();\r\n        long posisi_raiden = in.nextLong() - 1;  // mengubah one-based index menjadi zero based-index\r\n        Kuil kuil_raiden = pulau_hm.get(pulau_raiden).get_first();\r\n        set_raiden_shogun(kuil_raiden.get(posisi_raiden).data);\r\n    }\r\n    \r\n    public static void input_query_peperangan(){\r\n        long query_number = in.nextLong();\r\n        for (int i = 0; i < query_number; i++) {\r\n            String query = in.next();\r\n        \r\n            switch (query.charAt(0)){\r\n                case 'P':\r\n                    pisah();\r\n                    break;\r\n                case 'U':\r\n                    unifikasi();\r\n                    break;\r\n                case 'R':\r\n                    rise();\r\n                    break;\r\n                case 'Q':\r\n                    debug_print_semua_kuil();\r\n                    quake();\r\n                    debug_print_semua_kuil();\r\n                    break;\r\n                case 'C':\r\n                    crumble();\r\n                    break;\r\n                case 'S':\r\n                    if (query.charAt(1) == 'T'){\r\n                        stabilize();\r\n                    }else{\r\n                        sweeping();\r\n                    }\r\n                    break;\r\n                case 'G':\r\n                    gerak();\r\n                    break;\r\n                case 'T':\r\n                    if (query.charAt(2) == 'B'){\r\n                        tebas();\r\n                    }else{\r\n                        teleportasi();\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    public static void pisah(){\r\n        String nama_kuil = in.next();\r\n        Kuil kuil = kuil_hm.get(nama_kuil);\r\n        Pulau pulau_asal = kuil.__pulau;\r\n        \r\n        Pulau pulau_kiri = new Pulau(pulau_asal.nama);\r\n        Pulau pulau_kanan = new Pulau(nama_kuil);\r\n        \r\n        Pulau pulau_to_be_inserted = pulau_kiri;\r\n        \r\n        AbstractBundel<Kuil> temp_abs = pulau_asal.head.next;\r\n        while (temp_abs instanceof DataBundel){\r\n            DataBundel<Kuil> temp = (DataBundel<Kuil>) temp_abs;\r\n            if (temp.data == kuil) {\r\n                // dijamin pisah bukan kuil paling kiri\r\n//                DataBundel<Kuil> kuil_sebelumnya = ((DataBundel<Kuil>) temp.prev).data;\r\n//                kuil_sebelumnya.\r\n                \r\n                pulau_to_be_inserted = pulau_kanan;\r\n            }\r\n            temp.data.__pulau_senarai_bundel = pulau_to_be_inserted.push_back(temp.data);\r\n            temp.data.__pulau = pulau_to_be_inserted;\r\n            pulau_to_be_inserted.banyak_dataran += temp.data.size();\r\n            temp_abs = temp_abs.next;\r\n        }\r\n        \r\n        pulau_hm.put(pulau_kiri.nama, pulau_kiri);\r\n        pulau_hm.put(pulau_kanan.nama, pulau_kanan);\r\n        \r\n        out.print(pulau_kiri.banyak_dataran);\r\n        out.print(' ');\r\n        out.println(pulau_kanan.banyak_dataran);\r\n    }\r\n    \r\n    public static void unifikasi(){\r\n        int total_dataran_pulau_baru = 0;\r\n        \r\n        String nama_pulau_kiri = in.next();\r\n        String nama_pulau_kanan = in.next();\r\n        Pulau pulau_kiri = pulau_hm.get(nama_pulau_kiri);\r\n        Pulau pulau_kanan = pulau_hm.get(nama_pulau_kanan);\r\n        long banyak_kuil_yang_seharusnya = pulau_kiri.size() + pulau_kanan.size();\r\n        \r\n        pulau_kiri.banyak_dataran += pulau_kanan.banyak_dataran;\r\n    \r\n        AbstractBundel<Kuil> current = pulau_kanan.get_head().get_next();\r\n        while (current instanceof DataBundel){\r\n            DataBundel<Kuil> kuil_bundel = (DataBundel<Kuil>) current;\r\n            DataBundel<Kuil> temp = pulau_kiri.push_back(kuil_bundel.get_data());\r\n    \r\n            kuil_bundel.data.__pulau_senarai_bundel = temp;\r\n            kuil_bundel.data.__pulau = pulau_kiri;\r\n            current = current.get_next();\r\n        }\r\n        \r\n        pulau_hm.remove(nama_pulau_kanan);\r\n        assert pulau_kiri.size() == banyak_kuil_yang_seharusnya;\r\n        out.println(pulau_kiri.banyak_dataran);\r\n    }\r\n    \r\n    public static void rise(){\r\n        Pulau pulau = pulau_hm.get(in.next());\r\n        long h_exclusive = in.nextLong();\r\n        long x = in.nextLong();\r\n        long total_affected_dataran = 0;\r\n    \r\n        AbstractBundel<Kuil> kuil_bundel = pulau.get_head().next;\r\n        while (kuil_bundel instanceof DataBundel){\r\n            Kuil kuil = ((DataBundel<Kuil>) kuil_bundel).data;\r\n            total_affected_dataran += rise(kuil, h_exclusive+1, x);\r\n            kuil_bundel = kuil_bundel.next;\r\n        }\r\n        out.println(total_affected_dataran);\r\n    }\r\n    \r\n    public static long rise(Kuil kuil, long h_inclusive, long x){\r\n        assert x > 0;\r\n        KuilTree kuil_tree = kuil.tree;\r\n        \r\n        long number_of_affected_dataran = 0;\r\n        long ketinggian_data = h_inclusive;\r\n        long ketinggian_kumulatif = 0;\r\n        \r\n        // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        POSITION curr_position_in_parent = POSITION.LEFT;\r\n        IBstNode<Long> prev = kuil_tree.head;\r\n        BstData<Long> curr = kuil_tree.head.get_child(curr_position_in_parent);\r\n        \r\n        while (curr != null) {\r\n            ketinggian_kumulatif += curr.get_data();\r\n            \r\n            if (ketinggian_data > ketinggian_kumulatif) {\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n            }else if (ketinggian_data < ketinggian_kumulatif) {\r\n                curr_position_in_parent = POSITION.LEFT;\r\n    \r\n                curr.data += x;\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.left != null) {\r\n                    curr.left.data -= x;\r\n                    number_of_affected_dataran -= curr.left.get_count();\r\n        \r\n                    // akan di-kanselasi di loop berikutnya karena kita akan mengubah curr.left.data\r\n                    ketinggian_kumulatif += x;\r\n                }\r\n            }else {\r\n                curr.data += x;\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.left != null) {\r\n                    curr.left.data -= x;\r\n                    number_of_affected_dataran -= curr.left.get_count();\r\n                }\r\n                break;  // berusaha menambahkan data yang sudah ada\r\n            }\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n        \r\n        return number_of_affected_dataran;\r\n    }\r\n    \r\n    \r\n    public static void quake(){\r\n        Pulau pulau = pulau_hm.get(in.next());\r\n        long h_exclusive = in.nextLong();\r\n        long x = -in.nextLong();\r\n        long total_affected_dataran = 0;\r\n        \r\n        AbstractBundel<Kuil> kuil_bundel = pulau.get_head().next;\r\n        while (kuil_bundel instanceof DataBundel){\r\n            Kuil kuil = ((DataBundel<Kuil>) kuil_bundel).data;\r\n            total_affected_dataran += quake(kuil, h_exclusive-1, x);\r\n            kuil_bundel = kuil_bundel.next;\r\n        }\r\n        out.println(total_affected_dataran);\r\n    }\r\n    \r\n    public static long quake(Kuil kuil, long h_inclusive, long x){\r\n        assert x < 0;\r\n        KuilTree kuil_tree = kuil.tree;\r\n        \r\n        long number_of_affected_dataran = 0;\r\n        long ketinggian_data = h_inclusive;\r\n        long ketinggian_kumulatif = 0;\r\n        \r\n        // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        POSITION curr_position_in_parent = POSITION.RIGHT;\r\n        IBstNode<Long> prev = kuil_tree.head;\r\n        BstData<Long> curr = kuil_tree.head.get_child(curr_position_in_parent);\r\n        \r\n        while (curr != null) {\r\n            ketinggian_kumulatif += curr.get_data();\r\n        \r\n            if (ketinggian_data > ketinggian_kumulatif) {\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n                curr.data += x;\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.right != null) {\r\n                    curr.right.data -= x;\r\n                    number_of_affected_dataran -= curr.right.get_count();\r\n    \r\n                    // akan di-kanselasi di loop berikutnya karena kita akan ngubah curr.right.data\r\n                    ketinggian_kumulatif += x;\r\n                }\r\n            }else if (ketinggian_data < ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.LEFT;\r\n            else {\r\n                curr.data += x;\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.right != null) {\r\n                    curr.right.data -= x;\r\n                    number_of_affected_dataran -= curr.right.get_count();\r\n                }\r\n                break;  // berusaha menambahkan data yang sudah ada\r\n            }\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n    \r\n        return number_of_affected_dataran;\r\n    }\r\n    \r\n    public static void crumble(){\r\n        if (get_raiden_shogun().is_dataran_for_kuil()) {\r\n            out.println(0);\r\n            return;\r\n        }\r\n        \r\n        Dataran dataran_raiden = get_raiden_shogun();\r\n        set_raiden_shogun(\r\n                ((DataBundel<Dataran>) dataran_raiden.senarai_bundel.prev).data\r\n        );\r\n        out.println(dataran_raiden.get_ketinggian());\r\n        dataran_raiden.get_pulau().banyak_dataran -= 1;\r\n        dataran_raiden.delete_this();\r\n        dataran_raiden.bst_node.update_this_and_parents_height_count();\r\n        \r\n        /* TODO */\r\n    }\r\n    \r\n    public static void stabilize(){\r\n        if (get_raiden_shogun().is_dataran_for_kuil()){\r\n            out.println(0);\r\n            return;\r\n        }\r\n        \r\n        Kuil kuil = get_raiden_shogun().get_kuil();\r\n        Dataran dataran_raiden = get_raiden_shogun();\r\n        Dataran dataran_dikiri = get_raiden_shogun().dataran_di_kiri();\r\n        long tinggi_dataran_raiden = dataran_raiden.get_ketinggian();\r\n        long tinggi_dataran_dikiri = dataran_dikiri.get_ketinggian();\r\n        \r\n        Dataran dataran_yg_lebih_rendah = dataran_raiden;\r\n        long tinggi_terendah = tinggi_dataran_raiden;\r\n        if (tinggi_dataran_dikiri < tinggi_terendah){\r\n            dataran_yg_lebih_rendah = dataran_dikiri;\r\n            tinggi_terendah = tinggi_dataran_dikiri;\r\n        }\r\n        long banyak_dataran_old = dataran_yg_lebih_rendah.bst_node.get_internal_count();\r\n        \r\n        Dataran dataran_baru = new Dataran(null, null, null);\r\n        DataBundel<Dataran> dataran_data_bundel_baru_bst = new DataBundel<>(dataran_baru);\r\n        DataBundel<Dataran> dataran_data_bundel_baru_senarai = new DataBundel<>(dataran_baru);\r\n        dataran_yg_lebih_rendah.bst_node_bundel.insert_after_this(dataran_data_bundel_baru_bst);\r\n        \r\n        // dimasukkan ke kanannya raiden\r\n        dataran_raiden.senarai_bundel.insert_after_this(dataran_data_bundel_baru_senarai);\r\n    \r\n        dataran_baru.bst_node = dataran_yg_lebih_rendah.bst_node;\r\n        dataran_baru.bst_node_bundel = dataran_data_bundel_baru_bst;\r\n        dataran_baru.senarai_bundel = dataran_data_bundel_baru_senarai;\r\n        dataran_yg_lebih_rendah.get_pulau().banyak_dataran += 1;\r\n        dataran_baru.bst_node.update_this_and_parents_height_count();\r\n    \r\n    \r\n        long banyak_dataran_new = dataran_yg_lebih_rendah.bst_node.get_internal_count();\r\n        assert kuil.size() <= dataran_raiden.get_pulau().banyak_dataran;\r\n        assert banyak_dataran_old + 1 == banyak_dataran_new;\r\n        out.println(tinggi_terendah);\r\n    }\r\n    \r\n    \r\n    public static void gerak() {\r\n        String arah = in.next();\r\n        int banyak_langkah = in.nextInt();\r\n        \r\n        boolean ke_kiri = (arah.charAt(1) == 'I');\r\n        for (int i = 0; i < banyak_langkah; i++) {\r\n            gerak_sekali(ke_kiri);\r\n        }\r\n    \r\n        out.println(get_raiden_shogun().senarai_bundel.data.get_ketinggian());\r\n    }\r\n    public static void gerak_sekali(boolean ke_kiri){\r\n        Kuil kuil_saat_ini = (Kuil) get_raiden_shogun().senarai_bundel.senarai;\r\n        \r\n        if (ke_kiri){  // kiri\r\n            if (get_raiden_shogun().senarai_bundel.prev instanceof DataBundel)  // kalau dikirinya masih bagian kuil yg sama (bukan HeadNode)\r\n                set_raiden_shogun(\r\n                        ((DataBundel<Dataran>) get_raiden_shogun().senarai_bundel.prev).data\r\n                );\r\n            else{\r\n                DataBundel<Kuil> temp_kuil_lama = kuil_saat_ini.get_senarai_bundel_of_pulau();\r\n                assert temp_kuil_lama != null;  // kalau fail, mungkin soalnya salah? atau ada bug di tempat lain\r\n                \r\n                if (temp_kuil_lama.get_prev() instanceof DataBundel) {  // masih ada kuil di sebelumnya\r\n                    Kuil kuil_baru = ((DataBundel<Kuil>) temp_kuil_lama.get_prev()).data;\r\n                    set_raiden_shogun(\r\n                            ((DataBundel<Dataran>) kuil_baru.tail.prev).data\r\n                    );\r\n                }\r\n            }\r\n        }else{  // kanan\r\n            if (get_raiden_shogun().senarai_bundel.next instanceof DataBundel)  // kalau dikirinya masih ada dataran (bukan HeadNode)\r\n                set_raiden_shogun(\r\n                        ((DataBundel<Dataran>) get_raiden_shogun().senarai_bundel.next).data\r\n                );\r\n            else{\r\n                DataBundel<Kuil> temp_kuil_lama = kuil_saat_ini.get_senarai_bundel_of_pulau();\r\n                assert temp_kuil_lama != null;  // kalau fail, mungkin soalnya salah? atau ada bug di tempat lain\r\n                \r\n                if (temp_kuil_lama.get_next() instanceof DataBundel) {  // masih ada kuil di sebelumnya\r\n                    Kuil kuil_baru = ((DataBundel<Kuil>) temp_kuil_lama.get_next()).data;\r\n                    set_raiden_shogun(\r\n                            ((DataBundel<Dataran>) kuil_baru.head.next).data\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public static void tebas(){\r\n        String arah = in.next();\r\n        boolean ke_kiri = arah.charAt(1) == 'I';\r\n        int banyak_langkah = in.nextInt();\r\n    \r\n        Dataran dataran_raiden_awalnya = get_raiden_shogun();\r\n        long ketinggian_dataran = get_raiden_shogun().get_ketinggian();\r\n        \r\n        for (int i = 0; i < banyak_langkah; i++) {\r\n            if (!tebas(ke_kiri, ketinggian_dataran))\r\n                break;\r\n        }\r\n        \r\n        if (dataran_raiden_awalnya == get_raiden_shogun()){  // tidak berubah datarannya\r\n            out.println(0);\r\n            return;\r\n        }\r\n        \r\n        // harusnya kalau gaada bug, dataran_di_kanan maupun dataran_di_kiri tidak mengembalikan null\r\n        if (ke_kiri){\r\n            out.println(get_raiden_shogun().dataran_di_kanan().get_ketinggian());\r\n        }else{\r\n            Dataran temp = get_raiden_shogun().dataran_di_kiri();\r\n            out.println(temp.get_ketinggian());\r\n        }\r\n    }\r\n    \r\n    public static boolean tebas(boolean ke_kiri, long ketinggian){\r\n        if (ke_kiri){\r\n            if (get_raiden_shogun().bst_node_bundel.prev instanceof DataBundel){\r\n                set_raiden_shogun(\r\n                        ((DataBundel<Dataran>) get_raiden_shogun().bst_node_bundel.prev).data\r\n                );\r\n                return true;\r\n            }\r\n            \r\n            AbstractBundel<Kuil> current_kuil = get_raiden_shogun().get_bundel_of_pulau().prev;\r\n            while (current_kuil instanceof DataBundel){\r\n                Kuil kuil = ((DataBundel<Kuil>) current_kuil).data;\r\n                DataranBstNode dataran_bst_node = kuil.tree.get_path_to(ketinggian).b;\r\n                if (dataran_bst_node != null && dataran_bst_node.senarai.size() > 0){\r\n                    set_raiden_shogun(dataran_bst_node.senarai.get_last());\r\n                    return true;\r\n                }\r\n                current_kuil = current_kuil.prev;\r\n            }\r\n        }else{\r\n            if (get_raiden_shogun().bst_node_bundel.next instanceof DataBundel){\r\n                set_raiden_shogun(\r\n                        ((DataBundel<Dataran>) get_raiden_shogun().bst_node_bundel.next).data\r\n                );\r\n                return true;\r\n            }\r\n            \r\n            AbstractBundel<Kuil> current_kuil = get_raiden_shogun().get_bundel_of_pulau().next;\r\n            while (current_kuil instanceof DataBundel){\r\n                Kuil kuil = ((DataBundel<Kuil>) current_kuil).data;\r\n                DataranBstNode dataran_bst_node = kuil.tree.get_path_to(ketinggian).b;\r\n                if (dataran_bst_node != null && dataran_bst_node.senarai.size() > 0){\r\n                    set_raiden_shogun(dataran_bst_node.senarai.get_first());\r\n                    return true;\r\n                }\r\n                current_kuil = current_kuil.next;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    public static void teleportasi(){\r\n        String nama_kuil = in.next();\r\n        set_raiden_shogun(kuil_hm.get(nama_kuil).get_first());\r\n        out.println(get_raiden_shogun().get_ketinggian());\r\n    }\r\n    \r\n    public static void sweeping(){\r\n        String nama_pulau = in.next();\r\n        long tinggi_air = in.nextLong();\r\n        Pulau pulau = pulau_hm.get(nama_pulau);\r\n        \r\n        long banyak_sihir_diperlukan = 0;\r\n        \r\n        AbstractBundel<Kuil> curr_bundel = pulau.head.next;\r\n        while (curr_bundel instanceof DataBundel){\r\n            Kuil kuil = ((DataBundel<Kuil>) curr_bundel).data;\r\n            banyak_sihir_diperlukan += sweeping(kuil, tinggi_air-1);\r\n            curr_bundel = curr_bundel.next;\r\n        }\r\n        out.println(banyak_sihir_diperlukan);\r\n    }\r\n    \r\n    public static long sweeping(Kuil kuil, long h_inclusive){\r\n        long number_of_affected_dataran = 0;\r\n        long ketinggian_data = h_inclusive;\r\n        long ketinggian_kumulatif = 0;\r\n    \r\n        // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        POSITION curr_position_in_parent = POSITION.RIGHT;\r\n        IBstNode<Long> prev = kuil.tree.head;\r\n        BstData<Long> curr = kuil.tree.head.get_child(curr_position_in_parent);\r\n    \r\n        while (curr != null) {\r\n            ketinggian_kumulatif += curr.get_data();\r\n        \r\n            if (ketinggian_data > ketinggian_kumulatif) {\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.right != null)\r\n                    number_of_affected_dataran -= curr.right.get_count();\r\n            }else if (ketinggian_data < ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.LEFT;\r\n            else {\r\n                number_of_affected_dataran += curr.get_count();\r\n                if (curr.right != null)\r\n                    number_of_affected_dataran -= curr.right.get_count();\r\n                break;  // berusaha menambahkan data yang sudah ada\r\n            }\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n        \r\n        return number_of_affected_dataran;\r\n    }\r\n    \r\n    \r\n    \r\n    static class InputReader implements Closeable {\r\n        //    public static string something = \"aku\";\r\n        public BufferedReader bufferedReader;\r\n        public StringTokenizer stringTokenizer;\r\n    \r\n        public InputReader(InputStream inputStream){\r\n            this(inputStream, 32768);\r\n        }\r\n    \r\n        public InputReader(InputStream inputStream, int buffer_size){\r\n            // 32 MB buffer size\r\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream), buffer_size);\r\n            stringTokenizer = null;\r\n        }\r\n    \r\n        public String next(){\r\n            try{\r\n                while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()){\r\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        \r\n            return stringTokenizer.nextToken();\r\n        }\r\n    \r\n        public int nextInt(){ return Integer.parseInt(next()); }\r\n        public long nextLong(){ return Long.parseLong(next()); }\r\n        public short nextShort(){ return Short.parseShort(next()); }\r\n        public String nextLine() throws Exception { assert !stringTokenizer.hasMoreTokens(); return bufferedReader.readLine();}\r\n        public boolean nextBoolean(){ return Boolean.parseBoolean(next());}\r\n    \r\n        @Override\r\n        public void close() throws IOException {\r\n            bufferedReader.close();\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\nclass Pulau extends SenaraiBerantai<Kuil>{\r\n    String nama;\r\n    int banyak_dataran = 0;\r\n    public Pulau(String nama){\r\n        this.nama = nama;\r\n    }\r\n    \r\n    DataBundel<Kuil> find_kuil(String nama_kuil){\r\n        AbstractBundel<Kuil> temp_abs = this.head.next;\r\n        while (temp_abs instanceof DataBundel){\r\n            DataBundel<Kuil> temp = (DataBundel<Kuil>) temp_abs;\r\n            if (temp.data.nama.equals(nama_kuil))\r\n                return temp;\r\n            temp_abs = temp_abs.next;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    DataBundel<Kuil> find_kuil(Kuil kuil){\r\n        AbstractBundel<Kuil> temp_abs = this.head.next;\r\n        while (temp_abs instanceof DataBundel){\r\n            DataBundel<Kuil> temp = (DataBundel<Kuil>) temp_abs;\r\n            if (temp.data.equals(kuil))\r\n                return temp;\r\n            temp_abs = temp_abs.next;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    \r\n    Dataran get_dataran(long indeks_dataran){\r\n        AbstractBundel<Kuil> temp = this.head.next;\r\n        long indeks_dataran_temp = indeks_dataran;\r\n        \r\n        while (temp instanceof DataBundel){\r\n            DataBundel<Kuil> kuil_bundel = (DataBundel<Kuil>) temp;\r\n            if (kuil_bundel.data.size() < indeks_dataran_temp)\r\n                break;\r\n            indeks_dataran_temp -= kuil_bundel.data.size();\r\n            temp = temp.next;\r\n        }\r\n        \r\n        if (!(temp instanceof DataBundel))\r\n            throw new IllegalStateException(\"Index out of range\");\r\n        DataBundel<Kuil> kuil_bundel = (DataBundel<Kuil>) temp;\r\n        \r\n        return kuil_bundel.data.get(indeks_dataran_temp).data;\r\n    }\r\n}\r\n\r\n\r\nclass Kuil extends SenaraiBerantai<Dataran>{\r\n    String nama;\r\n    Pulau __pulau;\r\n    KuilTree tree = new KuilTree();\r\n    protected DataBundel<Kuil> __pulau_senarai_bundel;\r\n    \r\n    public Kuil(String nama, Pulau pulau, DataBundel<Kuil> this_kuil_data_bundel){\r\n        this.nama = nama;\r\n        this.__pulau = pulau;\r\n        __pulau_senarai_bundel = this_kuil_data_bundel;\r\n    }\r\n    \r\n    public DataBundel<Kuil> get_senarai_bundel_of_pulau(){\r\n        assert this.__pulau_senarai_bundel.senarai instanceof Pulau;\r\n        assert this.__pulau_senarai_bundel.senarai == __pulau;\r\n        return __pulau_senarai_bundel;\r\n    }\r\n    \r\n    public void set_pulau_senarai_bundel(DataBundel<Kuil> new_value){\r\n        __pulau_senarai_bundel = new_value;\r\n    }\r\n    \r\n    public Pulau get_pulau(){\r\n        assert this.__pulau_senarai_bundel.senarai instanceof Pulau;\r\n        assert this.__pulau_senarai_bundel.senarai == __pulau;\r\n        return __pulau;\r\n    }\r\n    \r\n    \r\n    public DataranBstNode reserve_node(Long ketinggian){\r\n        return tree.insert_data(ketinggian, new DataranDummyForReservingBstNode());\r\n    }\r\n    \r\n    public Dataran push_back(Long ketinggian){\r\n        Dataran dataran = new Dataran(null, null, null);\r\n        return push_back(ketinggian, dataran, tree.insert_data(ketinggian, dataran), true);\r\n    }\r\n    \r\n    public DataranBstNode cached_push_back(Long ketinggian, DataranBstNode node_source){\r\n        Dataran dataran = new Dataran(null, null, null);\r\n        DataranBstNode temp = tree.cached_insert_data_node(new DataranBstNode(ketinggian), dataran, node_source);\r\n        return push_back(ketinggian, dataran, temp, true).bst_node;\r\n    }\r\n    \r\n    public Dataran push_back(Long ketinggian, Dataran dataran, DataranBstNode bst_node, boolean increase_pulau_size){\r\n        dataran.senarai_bundel = super.push_back(dataran);\r\n        dataran.bst_node = bst_node;\r\n        dataran.bst_node_bundel = (DataBundel<Dataran>) dataran.bst_node.senarai.tail.prev;\r\n    \r\n        if (increase_pulau_size)\r\n            __pulau.banyak_dataran += 1;\r\n        assert this.size() <= __pulau.banyak_dataran;\r\n        return dataran;\r\n    }\r\n    \r\n    public DataranBstNode cached_reserve(Long ketinggian, DataranBstNode node_source){\r\n        return tree.cached_insert_data_node(new DataranBstNode(ketinggian),\r\n                                            new DataranDummyForReservingBstNode(), node_source);\r\n    }\r\n    \r\n    @Override\r\n    public DataBundel<Dataran> push_back(Dataran new_dataran){\r\n        throw new IllegalStateException(\"unimplemented\");\r\n    }\r\n}\r\n\r\n\r\nclass ComparableBundle<T extends Comparable<T>> extends DataBundel<T> implements Comparable<ComparableBundle<T>>{\r\n    public ComparableBundle(T data) {\r\n        super(data);\r\n    }\r\n    \r\n    @Override\r\n    public int compareTo(ComparableBundle<T> o) {\r\n        return this.data.compareTo(o.data);\r\n    }\r\n}\r\n\r\n\r\nclass DataranBstNode extends BstData<Long> implements Comparable<DataranBstNode> {\r\n    SenaraiBerantai<Dataran> senarai = new SenaraiBerantai<>();  // list dataran dengan ketinggian yang sama\r\n    \r\n    public DataranBstNode(long ketinggian_relatif) {\r\n        super(ketinggian_relatif);\r\n    }\r\n    \r\n    public long get_relative_height(){  // Not to be confused with get_height(). Both are two distinct items\r\n        return data;\r\n    }\r\n    \r\n    public int ___get_height(){\r\n        return super.___get_height();\r\n    }\r\n    \r\n    public int get_height(boolean dapatkan_ketinggian_node_dari_bawah){\r\n        if (dapatkan_ketinggian_node_dari_bawah)\r\n            return super.___get_height();\r\n        throw new IllegalStateException(\"Konfirmasi bahwa anda benar-benar ingin menghitung 'tinggi' dari leaf\");\r\n    }\r\n    \r\n    public long get_ketinggian(){\r\n        long height = 0;\r\n        IBstNode<Long> curr = this;\r\n        while (curr instanceof BstData){\r\n            DataranBstNode temp = (DataranBstNode) curr;\r\n            height += temp.get_relative_height();\r\n            curr = curr.get_parent();\r\n        }\r\n        return height;\r\n    }\r\n    \r\n    @Override\r\n    public void set_child(POSITION position, BstData<Long> new_child){\r\n        this.set_child(position, (DataranBstNode) new_child);\r\n    }\r\n    public void set_child(POSITION position, DataranBstNode new_child){\r\n        super.set_child_unchecked(position, new_child);\r\n    }\r\n    \r\n    @Override\r\n    public long get_internal_count(){\r\n        return this.senarai.size();\r\n    }\r\n    \r\n    @Override\r\n    public int compareTo(DataranBstNode o) {\r\n        throw new IllegalStateException(\"Not implemented\");\r\n    }\r\n}\r\n\r\nclass Dataran {\r\n    DataranBstNode bst_node;\r\n    DataBundel<Dataran> bst_node_bundel;\r\n    DataBundel<Dataran> senarai_bundel;\r\n    \r\n    Dataran(DataranBstNode dataran_bst_node, DataBundel<Dataran> bst_node_bundel, DataBundel<Dataran> data_bundel){\r\n        bst_node = dataran_bst_node;\r\n        this.bst_node_bundel = bst_node_bundel;\r\n        this.senarai_bundel = data_bundel;\r\n    }\r\n    \r\n    long get_ketinggian(){\r\n        return bst_node.get_ketinggian();\r\n    }\r\n    \r\n    Dataran dataran_di_kiri(){\r\n        // return dataran di kirinya, bahkan jika dataran di kirinya sudah berbeda segmen kuil.\r\n        // Jika di pulau sudah tidak ada lagi dataran di kirinya, maka return null\r\n        \r\n        if (senarai_bundel.prev instanceof DataBundel){\r\n            return ((DataBundel<Dataran>) senarai_bundel.prev).data;\r\n        }\r\n        \r\n        AbstractBundel<Kuil> kuil_sebelumnya_ = this.get_bundel_of_pulau().prev;\r\n        if (!(kuil_sebelumnya_ instanceof DataBundel)){\r\n            return null;\r\n        }\r\n        Kuil kuil_sebelumnya = ((DataBundel<Kuil>) kuil_sebelumnya_).data;\r\n        return kuil_sebelumnya.get_last();\r\n    }\r\n    \r\n    \r\n    Dataran dataran_di_kanan(){\r\n        // return dataran di kanannya, bahkan jika dataran di kanannya sudah berbeda segmen kuil.\r\n        // Jika di pulau sudah tidak ada lagi dataran di kanannya, maka return null\r\n        \r\n        if (senarai_bundel.next instanceof DataBundel){\r\n            return ((DataBundel<Dataran>) senarai_bundel.next).data;\r\n        }\r\n        \r\n        AbstractBundel<Kuil> kuil_sebelumnya_ = this.get_bundel_of_pulau().next;\r\n        if (!(kuil_sebelumnya_ instanceof DataBundel)){\r\n            return null;\r\n        }\r\n        Kuil kuil_setelahnya = ((DataBundel<Kuil>) kuil_sebelumnya_).data;\r\n        return kuil_setelahnya.get_first();\r\n    }\r\n    \r\n    boolean is_dataran_for_kuil(){\r\n        // cek apakah dataran yang diinjak saat ini merupakan kuil atau bukan.\r\n        // Dengan kata lain, cek apakah dataran ini merupakan dataran paling kiri dalam class senarai Kuil\r\n        return !(this.senarai_bundel.prev instanceof DataBundel);\r\n    }\r\n    \r\n    Kuil get_kuil(){\r\n        return (Kuil) senarai_bundel.senarai;\r\n    }\r\n    \r\n    DataBundel<Kuil> get_bundel_of_pulau(){\r\n        return get_kuil().get_senarai_bundel_of_pulau();\r\n    }\r\n    \r\n    Pulau get_pulau(){\r\n        return get_kuil().__pulau;\r\n    }\r\n    \r\n    public void delete_this(){\r\n        senarai_bundel.remove();\r\n        bst_node_bundel.remove();\r\n        \r\n        if (bst_node.senarai.size() == 0){\r\n            DataranBstNode kiri  = (DataranBstNode) bst_node.left;\r\n            DataranBstNode kanan = (DataranBstNode) bst_node.right;\r\n            /* TODO hapus kalau tidak berguna. Jangan lupa readjust nilai dari node-node child di bawahnya */\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        if (bst_node == null)\r\n            return \"D:null\";\r\n        return \"D:\" + get_ketinggian();\r\n    }\r\n}\r\n\r\nclass DataranDummyForReservingBstNode extends Dataran{\r\n    DataranDummyForReservingBstNode() {\r\n        super(null, null, null);\r\n    }\r\n}\r\n\r\nclass KuilTree extends BST<Long>{  // BST<Long> == DataranBstNode\r\n    \r\n    Triplet<IBstNode<Long>, DataranBstNode, ArrayList<POSITION>> get_path_to(long ketinggian){\r\n        // returns: prev, current, path\r\n        \r\n        long ketinggian_akumulatif = 0;\r\n        \r\n        ArrayList<POSITION> path = new ArrayList<>(30);\r\n        POSITION curr_pos = POSITION.RIGHT;  // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        IBstNode<Long> prev_node = head;\r\n        DataranBstNode curr_node = (DataranBstNode) head.child;\r\n        \r\n        while (curr_node != null){\r\n            ketinggian_akumulatif += curr_node.data;\r\n            if (ketinggian < ketinggian_akumulatif){\r\n                curr_pos = POSITION.LEFT;\r\n            }else if(ketinggian > ketinggian_akumulatif){\r\n                curr_pos = POSITION.RIGHT;\r\n            }else{\r\n                break;\r\n            }\r\n            prev_node = curr_node;\r\n            curr_node = (DataranBstNode) curr_node.get_child(curr_pos);\r\n            path.add(curr_pos);\r\n        }\r\n        return new Triplet<>(prev_node, curr_node, path);\r\n    }\r\n    \r\n    @Override\r\n    public BstData<Long> insert_data(Long ketinggian) {\r\n        throw new IllegalStateException(\"not implemented\");\r\n    }\r\n    public DataranBstNode insert_data(Long ketinggian, Dataran dataran) {\r\n        DataranBstNode temp = new DataranBstNode(ketinggian);\r\n        //noinspection RedundantCast\r\n        temp = insert_data_node((DataranBstNode) temp, dataran);\r\n        return temp;\r\n    }\r\n    \r\n    public DataranBstNode insert_data_node(DataranBstNode bst_data, Dataran dataran){\r\n        // insert  anode into the tree. Return RIGHT if it's its parent's right child. LEFT otherwise\r\n\r\n//        assert bst_data instanceof DataranBstNode;\r\n        assert bst_data.is_leaf();\r\n        assert bst_data.get_parent() == null;\r\n        \r\n        long ketinggian_data = bst_data.data;\r\n        long ketinggian_kumulatif = 0;\r\n    \r\n        // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        POSITION curr_position_in_parent = POSITION.RIGHT;\r\n        IBstNode<Long> prev = this.head;\r\n        BstData<Long> curr = head.get_child(curr_position_in_parent);\r\n        while (curr != null) {\r\n            ketinggian_kumulatif += curr.get_data();\r\n            \r\n            if (ketinggian_data > ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n            else if (ketinggian_data < ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.LEFT;\r\n            else\r\n                break;  // berusaha menambahkan data yang sudah ada\r\n            prev = curr;\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n    \r\n        DataranBstNode current = (DataranBstNode) curr;\r\n        if (current == null){  // jika DataranBstNode belum ada sebelumnya\r\n            assert ketinggian_data != ketinggian_kumulatif;\r\n            \r\n            bst_data.set_data(ketinggian_data - ketinggian_kumulatif);\r\n            current = bst_data;\r\n            prev.set_child(curr_position_in_parent, bst_data, false);\r\n        }\r\n        \r\n        if (!(dataran instanceof DataranDummyForReservingBstNode))\r\n            current.senarai.add(dataran);\r\n        else\r\n            current.update_this_and_parents_height_count();\r\n        return current;\r\n    }\r\n    \r\n    public DataranBstNode cached_insert_data_node(DataranBstNode bst_data, Dataran dataran,\r\n                                                  DataranBstNode entry_point){\r\n        // insert  anode into the tree. Return RIGHT if it's its parent's right child. LEFT otherwise\r\n\r\n//        assert bst_data instanceof DataranBstNode;\r\n        assert bst_data.is_leaf();\r\n        assert bst_data.get_parent() == null;\r\n        \r\n        long ketinggian_data = bst_data.data;\r\n        long ketinggian_kumulatif = 0;\r\n    \r\n        // Harus right supaya rootnya bernilai positif (6 - 0 instead of 0 - 6)\r\n        POSITION curr_position_in_parent = entry_point.find_child_pos(entry_point);\r\n        IBstNode<Long> prev = entry_point.parent;\r\n        BstData<Long> curr = entry_point;\r\n        while (curr != null) {\r\n            ketinggian_kumulatif += curr.get_data();\r\n            \r\n            if (ketinggian_data > ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n            else if (ketinggian_data < ketinggian_kumulatif)\r\n                curr_position_in_parent = POSITION.LEFT;\r\n            else\r\n                break;  // berusaha menambahkan data yang sudah ada\r\n            prev = curr;\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n    \r\n        DataranBstNode current = (DataranBstNode) curr;\r\n        if (current == null){  // jika DataranBstNode belum ada sebelumnya\r\n            assert ketinggian_data != ketinggian_kumulatif;\r\n            \r\n            bst_data.set_data(ketinggian_data - ketinggian_kumulatif);\r\n            current = bst_data;\r\n            prev.set_child(curr_position_in_parent, bst_data, false);\r\n        }\r\n        \r\n        if (!(dataran instanceof DataranDummyForReservingBstNode))\r\n            current.senarai.add(dataran);\r\n        else\r\n            current.update_this_and_parents_height_count();\r\n        return current;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        if (this.head.child == null){\r\n            return \"BST-Empty\";\r\n        }\r\n        return this.head.child.tree_str();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass BST<T extends Comparable<T>> {\r\n    BstHead<T> head = new BstHead<>();\r\n    \r\n    public void insert_datas(T[] datas){\r\n        for (T data : datas) {\r\n            insert_data(data);\r\n        }\r\n    }\r\n    public <U extends Iterable<T>> void insert_datas(U datas){\r\n        for (T data : datas) {\r\n            insert_data(data);\r\n        }\r\n    }\r\n    public BstData<T> insert_data(T data){\r\n        BstData<T> temp = new BstData<>(data);\r\n        insert_data_node(temp);\r\n        return temp;\r\n    }\r\n    public BstData<T> root(){\r\n        return head.child;\r\n    }\r\n    \r\n    public POSITION insert_data_node(BstData<T> new_node){\r\n        // insert  anode into the tree. Return RIGHT if it's its parent's right child. LEFT otherwise\r\n        assert new_node.is_leaf();\r\n        assert new_node.get_parent() == null;\r\n        \r\n        POSITION curr_position_in_parent = POSITION.LEFT;  // RIGHT juga boleh. bebas\r\n        IBstNode<T> prev = head;\r\n        BstData<T> curr = head.get_child(curr_position_in_parent);\r\n        while (curr != null){\r\n            int temp = new_node.get_data().compareTo(curr.get_data());\r\n            if (temp > 0)\r\n                curr_position_in_parent = POSITION.RIGHT;\r\n            else if (temp < 0)\r\n                curr_position_in_parent = POSITION.LEFT;\r\n            else\r\n                return null;  // berusaha menambahkan data yang sudah ada\r\n            prev = curr;\r\n            curr = curr.get_child(curr_position_in_parent);\r\n        }\r\n        \r\n        assert new_node.___get_height() == 0;\r\n        prev.set_child(curr_position_in_parent, new_node);\r\n        \r\n        return curr_position_in_parent;\r\n    }\r\n    \r\n    public BstData<T> find_node(T data){\r\n        // return the node containing the data if exists. null otherwise\r\n        \r\n        BstData<T> temp = this.head.get_child();\r\n        POSITION direction = POSITION.LEFT;\r\n        while (temp != null && !temp.get_data().equals(data)){\r\n            if (data.compareTo(temp.get_data()) > 0)\r\n                direction = POSITION.RIGHT;\r\n            else\r\n                direction = POSITION.LEFT;\r\n            temp = temp.get_child(direction);\r\n        }\r\n        \r\n        return temp;\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (!(o instanceof BST)) return false;\r\n        BST<?> BST = (BST<?>) o;\r\n        return Objects.equals(head.get_child(), BST.head.get_child());\r\n    }\r\n    \r\n    public void print() {\r\n        print(-1);\r\n    }\r\n    \r\n    public void print(int data_length) {\r\n        print(data_length, 1, true);\r\n    }\r\n    public void print(int data_length, int margin, boolean show_count) {\r\n        if (this.head.child == null)\r\n            System.out.println(\"AvlEmpty\");\r\n        else\r\n            this.head.child.print_tree(data_length, margin, show_count);\r\n    }\r\n}\r\n\r\nenum POSITION {\r\n    LEFT, RIGHT;\r\n    \r\n    public POSITION complement(){\r\n        switch (this){\r\n            case RIGHT:\r\n                return LEFT;\r\n            case LEFT:\r\n                return RIGHT;\r\n        }\r\n        throw new IllegalStateException();\r\n    }\r\n}\r\n\r\ninterface BstIterateFunction {\r\n    <T extends Comparable<T>> boolean invoke(BstData<T> node, int depth);\r\n}\r\n\r\n\r\ninterface IBstNode<T extends Comparable<T>> {\r\n    BstData<T> get_child(POSITION child_position);\r\n    BstData<T> get_left();\r\n    BstData<T> get_right();\r\n    void _set_child(POSITION child_position, BstData<T> new_child);\r\n    \r\n    default void set_child(POSITION child_position, BstData<T> new_child){\r\n        set_child(child_position, new_child, true);\r\n    }\r\n    default void set_child(POSITION child_position, BstData<T> new_child, boolean update_height){\r\n        /*\r\n         * Melepaskan child pada child_position saat ini, dan melepaskan new_child dari parentnya saat ini.\r\n         * Setelah itu, menghubungkan new_child dengan node ini, dan meng-adjust ulang height node ini serta parentsnya\r\n         */\r\n        if (new_child == this)\r\n            throw new IllegalStateException(\"Trying to make a circular child\");\r\n        if (this.get_child(child_position) != null)\r\n            this.get_child(child_position).detach_from_parent(false);\r\n        if (new_child != null){\r\n            if (new_child.parent != null)\r\n                new_child.detach_from_parent(true);\r\n            new_child.parent = this;\r\n        }\r\n        this._set_child(child_position, new_child);\r\n        if (update_height)\r\n            this.update_this_and_parents_height_count();\r\n    }\r\n    int ___get_height();\r\n    void _set_height(int new_height);\r\n    IBstNode<T> get_parent();\r\n    void detach_from_parent();\r\n    \r\n    void _set_parent(IBstNode<T> new_parent);\r\n    void set_parent(POSITION pos, IBstNode<T> new_parent);\r\n    int update_this_height_and_count();  // returns its height\r\n    IBstNode<T> update_parents_height_and_count();\r\n    IBstNode<T> update_this_and_parents_height_count();\r\n    IBstNode<T> update_this_and_parents_height_count(int initial_height);\r\n    POSITION find_child_pos(IBstNode<T> child);\r\n    \r\n    long get_count();\r\n    void _set_count(long new_count);\r\n    default long get_internal_count(){  // the weight of each node\r\n        return 1;\r\n    }\r\n}\r\n\r\n/*interface BstData<T extends Comparable<T>> extends IBstNode<T> {\r\n    T get_data();\r\n    void set_data(T new_data);\r\n    BstData<T> get_right();\r\n    void set_right(BstData<T> new_data);\r\n    BstData<T> get_left();\r\n    void set_left(BstData<T> new_data);\r\n    \r\n    boolean is_leaf();\r\n    void detach_this_only();\r\n    Iterator<Pair<BstData<T>, Integer>> inorder_iterator();\r\n    BstData<T> successor_inorder();\r\n    BstData<T> predecessor_inorder();\r\n    \r\n    boolean equals(boolean check_height, Object o);\r\n    void print();\r\n    void print(int data_length, int margin_size);\r\n}*/\r\n\r\ninterface BstSpecialNode<T extends Comparable<T>> extends IBstNode<T> {\r\n}\r\n\r\nclass BstHead<T extends Comparable<T>> implements BstSpecialNode<T> {\r\n    BstData<T> child;\r\n    \r\n    @Override\r\n    public BstData<T> get_child(POSITION child_position) {\r\n        return child;\r\n    }\r\n    \r\n    @Override\r\n    public BstData<T> get_left() {\r\n        return this.child;\r\n    }\r\n    \r\n    @Override\r\n    public BstData<T> get_right() {\r\n        return this.child;\r\n    }\r\n    \r\n    @Override\r\n    public void _set_child(POSITION child_position, BstData<T> new_child) {\r\n        this.child = new_child;\r\n    }\r\n    \r\n    \r\n    \r\n    public BstData<T> get_child(){\r\n        return child;\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public int ___get_height() {\r\n        if (this.child == null)\r\n            return -1;  // kalau BST hanya terdiri atas root, maka heightnya 0. Ini bahkan tidak punya root\r\n        return this.child.___get_height();\r\n    }\r\n    \r\n    @Override\r\n    public void _set_height(int new_height) {\r\n    }\r\n    \r\n    @Override\r\n    public IBstNode<T> get_parent() {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    public void detach_from_parent() {\r\n    }\r\n    \r\n    @Override\r\n    public void _set_parent(IBstNode<T> new_parent) {\r\n    }\r\n    \r\n    @Override\r\n    public void set_parent(POSITION pos, IBstNode<T> new_parent) {\r\n    }\r\n    \r\n    @Override\r\n    public int update_this_height_and_count() {\r\n        return this.___get_height();\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public IBstNode<T> update_parents_height_and_count() {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    public IBstNode<T> update_this_and_parents_height_count() {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    public IBstNode<T> update_this_and_parents_height_count(int initial_height) {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    public POSITION find_child_pos(IBstNode<T> child) {\r\n        if (child != this.child)\r\n            return null;\r\n        return POSITION.LEFT;\r\n    }\r\n    \r\n    @Override\r\n    public long get_count() {\r\n        if (this.child == null)\r\n            return 0;\r\n        return this.child.count;\r\n    }\r\n    \r\n    @Override\r\n    public void _set_count(long new_count) {\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"BstHead{}\";\r\n    }\r\n}\r\n\r\nclass BstData<T extends Comparable<T>> implements IBstNode<T> {\r\n    protected IBstNode<T> parent;\r\n    protected BstData<T> left;\r\n    protected BstData<T> right;\r\n    protected int height = 0;\r\n    protected long count = 0;\r\n    public T data;\r\n    \r\n    public BstData(T data){\r\n        this.data = data;\r\n    }\r\n    \r\n    public BstData(IBstNode<T> parent, T data){\r\n        this.parent = parent;\r\n        this.data = data;\r\n    }\r\n    \r\n    public void detach_from_parent(){\r\n        detach_from_parent(true);\r\n    }\r\n    public void detach_from_parent(boolean adjust_parent_height){\r\n        if (this.parent == null)\r\n            return;\r\n        \r\n        POSITION position = this.parent.find_child_pos(this);\r\n        assert position != null;\r\n        \r\n        if (adjust_parent_height) {\r\n            int parent_new_height = 0;\r\n            if (parent.get_child(position.complement()) != null)\r\n                parent_new_height = parent.get_child(position.complement()).___get_height() + 1;\r\n            parent._set_height(parent_new_height);\r\n            parent.update_parents_height_and_count();\r\n        }\r\n        parent._set_child(position, null);\r\n        this._set_parent(null);\r\n    }\r\n    \r\n    \r\n    public void _set_parent(IBstNode<T> new_parent) {\r\n        this.parent = new_parent;\r\n    }\r\n    \r\n    @Override\r\n    public void set_parent(POSITION pos, IBstNode<T> new_parent) {\r\n        new_parent.set_child(pos, this);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    public IBstNode<T> update_this_and_parents_height_count(int initial_height){\r\n        this.update_this_height_and_count();\r\n        this._set_height(initial_height);\r\n        return this.update_parents_height_and_count();\r\n    }\r\n    \r\n    public IBstNode<T> update_this_and_parents_height_count(){\r\n        this.update_this_height_and_count();\r\n        return this.update_parents_height_and_count();\r\n    }\r\n    \r\n    public int update_this_height_and_count(){\r\n        int left_height = -1;\r\n        int right_height = -1;\r\n        \r\n        long left_count = 0;\r\n        long right_count = 0;\r\n        \r\n        if (this.left != null) {\r\n            left_height = this.left.height;\r\n            left_count = this.left.get_count();\r\n        }\r\n        if (this.right != null) {\r\n            right_height = this.right.height;\r\n            right_count = this.right.get_count();\r\n        }\r\n        \r\n        this.height = Math.max(left_height, right_height) + 1;\r\n        this.count = left_count + right_count + get_internal_count();\r\n        return this.height;\r\n    }\r\n    \r\n    public IBstNode<T> update_parents_height_and_count(){\r\n        /*\r\n         * Return null if all of its parents are updated, or return the first unupdated parents\r\n         * parents = predecessor. Not to be confused with 'predecessor' in predecessor_inorder()\r\n         */\r\n        \r\n        if (this.parent == null)\r\n            return null;\r\n        IBstNode<T> temp_node = this.get_parent();\r\n        int prev_height = temp_node.___get_height();\r\n        \r\n        while (temp_node != null){\r\n            int curr_height = temp_node.update_this_height_and_count();\r\n//            if (curr_height == prev_height)\r\n//                break;\r\n            temp_node = temp_node.get_parent();\r\n        }\r\n        return temp_node;\r\n    }\r\n    \r\n    \r\n    public boolean is_leaf() {\r\n        return this.left == null && this.right == null;\r\n    }\r\n    \r\n    \r\n    public void detach_this_only() {\r\n        if (this.is_leaf()){\r\n            this.detach_from_parent();\r\n            return;\r\n        }\r\n        BstData<T> pengganti;\r\n        BstData<T> this_left = this.left;\r\n        BstData<T> this_right = this.right;\r\n        IBstNode<T> this_parent = this.parent;\r\n        POSITION this_pos_in_parent = this.parent.find_child_pos(this);\r\n        \r\n        if (this.left == null || this.right == null){  // kalau node yg mau dihapus punya satu anak\r\n            this.detach_from_parent(false);\r\n            \r\n            pengganti = this.left;\r\n            if (this.right != null)\r\n                pengganti = this.right;\r\n            pengganti.detach_from_parent(true);\r\n            \r\n            this_parent.set_child(this_pos_in_parent, pengganti);\r\n        }else{  // kalau node yg mau dihapus punya dua anak\r\n            pengganti = this.predecessor_inorder();\r\n            assert pengganti.is_leaf();\r\n            pengganti.detach_from_parent(true);\r\n            this.detach_from_parent(false);\r\n            this_left.detach_from_parent(false);\r\n            this_right.detach_from_parent(false);\r\n            \r\n            this_parent._set_child(this_pos_in_parent, pengganti);\r\n            pengganti._set_parent(this_parent);\r\n            pengganti._set_child(POSITION.LEFT, this_left);\r\n            pengganti._set_child(POSITION.RIGHT, this_right);\r\n            this_left._set_parent(pengganti);\r\n            this_right._set_parent(pengganti);\r\n        }\r\n        pengganti.update_this_and_parents_height_count();\r\n    }\r\n    \r\n    \r\n    public Iterator<Pair<BstData<T>, Integer>> inorder_iterator() {\r\n        return new InorderIterator();\r\n    }\r\n    \r\n    \r\n    public BstData<T> successor_inorder() {\r\n        if (this.right == null)\r\n            return null;\r\n        BstData<T> temp = this.right;\r\n        while (true){\r\n            if (temp.get_left() == null)\r\n                return temp;\r\n            temp = temp.get_left();\r\n        }\r\n    }\r\n    \r\n    public BstData<T> predecessor_inorder() {\r\n        if (this.left == null)\r\n            return null;\r\n        BstData<T> temp = this.left;\r\n        while (true){\r\n            if (temp.get_right() == null)\r\n                return temp;\r\n            temp = temp.get_right();\r\n        }\r\n    }\r\n    \r\n    \r\n    class InorderIterator implements Iterator<Pair<BstData<T>, Integer>> {\r\n        // Each iteration returns a tuple, where the left tuple is the iterated node, and the right tuple is the depth\r\n        \r\n        ArrayList<Triplet<BstData<T>, Boolean, Integer>> stack =\r\n                new ArrayList<>(4 * BstData.this.___get_height() + 5);\r\n        \r\n        public InorderIterator() {\r\n            stack.add(new Triplet<>(BstData.this, false, 0));\r\n        }\r\n        \r\n        public void process_next(){\r\n            while (!stack.isEmpty()){\r\n                if (stack.get(stack.size() - 1).b){\r\n                    break;\r\n                }else{\r\n                    Triplet<BstData<T>, Boolean, Integer> current_tuple = stack.remove(stack.size() - 1);\r\n                    \r\n                    if (current_tuple.a.get_right() != null)\r\n                        stack.add(new Triplet<>(current_tuple.a.get_right(), false, current_tuple.c + 1));\r\n                    stack.add(new Triplet<>(current_tuple.a, true, current_tuple.c));\r\n                    if (current_tuple.a.get_left() != null)\r\n                        stack.add(new Triplet<>(current_tuple.a.get_left(), false, current_tuple.c + 1));\r\n                }\r\n            }\r\n            \r\n            assert stack.isEmpty() || stack.get(stack.size()-1).b;\r\n        }\r\n        \r\n        \r\n        public boolean hasNext() {\r\n            process_next();\r\n            return !stack.isEmpty();\r\n        }\r\n        \r\n        \r\n        public Pair<BstData<T>, Integer> next() {\r\n            process_next();\r\n            Triplet<BstData<T>, Boolean, Integer> popped = stack.remove(stack.size() - 1);\r\n            return new Pair<>(popped.a, popped.c);\r\n        }\r\n        \r\n        \r\n        public void remove() {\r\n            next().a.detach_from_parent();\r\n        }\r\n        \r\n    }\r\n\r\n/*\r\n    public boolean inorder_traversal(BstIterateFunction function) {\r\n        ArrayList<Triplet<BstData<T>, Boolean, Integer>> stack = new ArrayList<>(4 * this.get_height() + 5);\r\n        stack.add(new Triplet<>(this, false, 0));\r\n        \r\n        while (!stack.isEmpty()){\r\n            Triplet<BstData<T>, Boolean, Integer> current_tuple = stack.remove(stack.size() - 1);\r\n            if (current_tuple.b){\r\n                function.invoke(current_tuple.a, current_tuple.c);\r\n            }else{\r\n                if (current_tuple.a.get_right() != null)\r\n                    stack.add(new Triplet<>(current_tuple.a.get_right(), false, current_tuple.c + 1));\r\n                stack.add(new Triplet<>(current_tuple.a, true, current_tuple.c));\r\n                if (current_tuple.a.get_left() != null)\r\n                    stack.add(new Triplet<>(current_tuple.a.get_left(), false, current_tuple.c + 1));\r\n            }\r\n        }\r\n        \r\n        int depth = 0;\r\n        \r\n        return false;\r\n    }\r\n    */\r\n    \r\n    public BstData<T> get_child(POSITION child_position) {\r\n        if (child_position == POSITION.LEFT)\r\n            return this.left;\r\n        return this.right;\r\n    }\r\n    \r\n    public T get_data() {\r\n        return this.data;\r\n    }\r\n    \r\n    \r\n    public void set_data(T new_data) {\r\n        this.data = new_data;\r\n    }\r\n    \r\n    \r\n    public BstData<T> get_right() {\r\n        return this.right;\r\n    }\r\n    \r\n    @Override\r\n    public void set_child(POSITION child_position, BstData<T> new_child){\r\n        boolean trying_to_set_new_child_in_the_left = child_position.equals(POSITION.LEFT);\r\n        boolean new_child_should_be_in_the_left = new_child.get_data().compareTo(this.get_data()) < 0;\r\n        \r\n        if (trying_to_set_new_child_in_the_left == new_child_should_be_in_the_left)\r\n            IBstNode.super.set_child(child_position, new_child);\r\n        else\r\n            throw new IllegalStateException(\"Trying to put child in the wrong position\");\r\n    }\r\n    \r\n    public void set_child_unchecked(POSITION child_position, BstData<T> new_child){\r\n        IBstNode.super.set_child(child_position, new_child);\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public void _set_child(POSITION child_position, BstData<T> new_child) {\r\n        if (child_position == POSITION.LEFT)\r\n            this.left = new_child;\r\n        else if (child_position == POSITION.RIGHT)\r\n            this.right = new_child;\r\n        else\r\n            throw new IllegalStateException(\"Setting child to null position\");\r\n    }\r\n    \r\n    \r\n    public void _set_right(BstData<T> new_data) {\r\n        this.right = new_data;\r\n    }\r\n    \r\n    \r\n    public BstData<T> get_left() {\r\n        return this.left;\r\n    }\r\n    \r\n    \r\n    public void _set_left(BstData<T> new_data) {\r\n        this.left = new_data;\r\n    }\r\n    \r\n    \r\n    \r\n    public int ___get_height() {\r\n        return this.height;\r\n    }\r\n    \r\n    \r\n    public void _set_height(int new_height) {\r\n        this.height = new_height;\r\n    }\r\n    \r\n    \r\n    public IBstNode<T> get_parent() {\r\n        return parent;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    public POSITION find_child_pos(IBstNode<T> child) {\r\n        if (child == this.left)\r\n            return POSITION.LEFT;\r\n        if (child == this.right)\r\n            return POSITION.RIGHT;\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    public long get_count() {\r\n        return this.count;\r\n    }\r\n    \r\n    @Override\r\n    public void _set_count(long new_count) {\r\n        this.count = new_count;\r\n    }\r\n    \r\n    \r\n    public String toString() {\r\n        return \"<\" + data + \">\";\r\n    }\r\n    \r\n    \r\n    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\r\n    public boolean equals(Object o) {\r\n        return this.equals(false, o);\r\n    }\r\n    \r\n    \r\n    public boolean equals(boolean check_height, Object o) {\r\n        if (this == o) return true;\r\n        if (!(o instanceof BstData)) return false;\r\n        //noinspection unchecked\r\n        BstData<T> avl_data = (BstData<T>) o;\r\n        \r\n        if (! avl_data.get_data().equals(this.get_data()))\r\n            return false;\r\n        \r\n        if (!check_height && this.height != avl_data.height)\r\n            return false;\r\n        \r\n        \r\n        if (this.is_leaf())\r\n            return true;\r\n        \r\n        boolean ret1 = true;\r\n        boolean ret2 = true;\r\n        \r\n        if (this.left == null){\r\n            if (avl_data.left != null)\r\n                return false;\r\n        }else if (! this.left.get_data().equals(avl_data.left.get_data()))\r\n            return false;\r\n        else if (this.left != null)\r\n            ret1 = this.left.equals(check_height, avl_data.left);\r\n        \r\n        if (this.right == null){\r\n            if (avl_data.right != null)\r\n                return false;\r\n        }else if (! this.right.get_data().equals(avl_data.right.get_data()))\r\n            return false;\r\n        else if (this.right != null)\r\n            ret2 = this.right.equals(check_height, avl_data.right);\r\n        \r\n        \r\n        return  ret1 && ret2;\r\n    }\r\n    \r\n    \r\n    public void print_tree() {\r\n        print_tree(-1, 1, true);\r\n    }\r\n    \r\n    \r\n    public void print_tree(int data_length, int margin_size, boolean show_count) {\r\n        System.out.println(tree_str(data_length, margin_size, show_count));\r\n    }\r\n    \r\n    public String tree_str() {\r\n        return tree_str(-1, 1, true);\r\n    }\r\n    \r\n    public String tree_str(int data_length, int margin_size, boolean show_count) {\r\n        int min_length = data_length;\r\n        String padding = str_multiply(\" \", data_length + margin_size);\r\n        String margin = str_multiply(\" \", margin_size);\r\n        \r\n        \r\n        ArrayList<ArrayList<String>> arr = new ArrayList<>(this.height+2);\r\n        for (int i = 0; i < this.height+1; i++) {\r\n            arr.add(new ArrayList<>(this.height * 4));\r\n        }\r\n        \r\n        \r\n        InorderIterator it = new InorderIterator();\r\n        while (it.hasNext()){\r\n            Pair<BstData<T>, Integer> temp = it.next();\r\n            int current_depth = temp.b;\r\n    \r\n    \r\n            String outputted = temp.a.get_data().toString();\r\n            if (show_count)\r\n                outputted = String.format(\"%s:%d\", temp.a.get_data().toString(), temp.a.get_count());\r\n    \r\n            \r\n            if (data_length == -1) {\r\n                min_length = outputted.length();\r\n                padding = str_multiply(\" \", min_length + margin_size);\r\n            }\r\n            \r\n            for (int i = 0; i < arr.size(); i++) {\r\n                if (i != current_depth)\r\n                    arr.get(i).add(padding);\r\n                else {\r\n                    String temp_output = outputted;\r\n                    temp_output = String.format(\"%\" + min_length + \"s\", temp_output);\r\n                    arr.get(i).add(temp_output + margin);\r\n                }\r\n            }\r\n        }\r\n        \r\n        StringBuilder ret = new StringBuilder(this.height * 20);\r\n        for (ArrayList<String> strings : arr) {\r\n            for (int j = 0; j < strings.size(); j++) {\r\n                ret.append(strings.get(j));\r\n            }\r\n            ret.append('\\n');\r\n        }\r\n        return ret.toString();\r\n    }\r\n    \r\n    @SuppressWarnings(\"StringRepeatCanBeUsed\")\r\n    public static String str_multiply(String str, int number){\r\n        StringBuilder temp = new StringBuilder(number * str.length() + 2);\r\n        for (int i = 0; i < number; i++) {\r\n            temp.append(' ');\r\n        }\r\n        return temp.toString();\r\n    }\r\n    \r\n    \r\n    public int hashCode() {\r\n        return Objects.hash(data);\r\n    }\r\n}\r\n\r\n\r\nclass sortings{\r\n    public static <T extends Comparable<T>> void merge_sort(ArrayList<T> to_be_sorted){\r\n        merge_sort(to_be_sorted, new ArrayList<>(to_be_sorted.size()+5));\r\n    }\r\n    public static <T extends Comparable<T>> void merge_sort(ArrayList<T> to_be_sorted, ArrayList<T> temporary){\r\n        merge_sort(to_be_sorted, temporary, 0, to_be_sorted.size()-1);\r\n    }\r\n    \r\n    public static <T extends Comparable<T>> void merge_sort(ArrayList<T> to_be_sorted, ArrayList<T> temporary,\r\n                                                            int l, int r){\r\n        ArrayList<Quadruplet<Integer, Integer, Boolean, Integer>>\r\n                stack = new ArrayList<>(200);\r\n        stack.add(new Quadruplet<>(l, r, false, -1));\r\n        int m;\r\n        \r\n        while (!stack.isEmpty()){\r\n            Quadruplet<Integer, Integer, Boolean, Integer> curr_task = stack.remove(stack.size() - 1);\r\n            l = curr_task.a;\r\n            r = curr_task.b;\r\n            \r\n            if (curr_task.c){  // c true -> merge. c false -> divide\r\n                merge(to_be_sorted, temporary, curr_task);\r\n            }else if (l != r){\r\n                m = (curr_task.a + curr_task.b) / 2;\r\n                stack.add(new Quadruplet<>(l, r, true, m));\r\n                stack.add(new Quadruplet<>(l, m, false, -1));\r\n                stack.add(new Quadruplet<>(m+1, r, false, -1));\r\n            }\r\n        }\r\n    }\r\n    \r\n    public static <T extends Comparable<T>, U>\r\n    void merge(ArrayList<T> arr, ArrayList<T> temporary,\r\n               Quadruplet<Integer, Integer, U, Integer> segment){\r\n        if (segment.a.equals(segment.b))\r\n            return;\r\n        temporary.clear();\r\n        \r\n        int kiri_start = segment.a;\r\n        int kiri_end = segment.d;\r\n        int kanan_start = segment.d + 1;\r\n        int kanan_end = segment.b;\r\n        \r\n        loop_luar:\r\n        while (kiri_start <= kiri_end && kanan_start <= kanan_end){\r\n            while (arr.get(kiri_start).compareTo(arr.get(kanan_start)) <= 0){\r\n                temporary.add(arr.get(kiri_start));\r\n                kiri_start += 1;\r\n                if (kiri_start > kiri_end)\r\n                    break loop_luar;\r\n            }\r\n            while (arr.get(kanan_start).compareTo(arr.get(kiri_start)) < 0){\r\n                temporary.add(arr.get(kanan_start));\r\n                kanan_start += 1;\r\n                if (kanan_start > kanan_end)\r\n                    break loop_luar;\r\n            }\r\n        }\r\n        \r\n        // kalau kirinya masih ada, pindahin/copy ke temporary\r\n        for (; kiri_start <= kiri_end; kiri_start++) {\r\n            temporary.add(arr.get(kiri_start));\r\n        }\r\n        \r\n        // pindahin kembali dari temporary ke sumber array\r\n        int curr_index = segment.a;\r\n        for (int i = 0; i < temporary.size(); i++) {\r\n            arr.set(curr_index+i, temporary.get(i));\r\n        }\r\n    }\r\n    \r\n    public static <T extends Comparable<T>> void splitter(ArrayList<T> sorted_arr, BiConsumer<Integer, T> func){\r\n        splitter(sorted_arr, func, new Pair<>(0, sorted_arr.size()-1));\r\n    }\r\n    public static <T extends Comparable<T>> void splitter(ArrayList<T> sorted_arr, BiConsumer<Integer, T> func,\r\n                                                          Pair<Integer, Integer> segment){\r\n        ArrayList<Pair<Integer, Integer>> stack = new ArrayList<>(200);\r\n        stack.add(segment);\r\n        \r\n        while (!stack.isEmpty()){\r\n            Pair<Integer, Integer> curr_segment = stack.remove(stack.size() - 1);\r\n            \r\n            if (curr_segment.a > curr_segment.b)\r\n                continue;\r\n            \r\n            int m = (curr_segment.a + curr_segment.b) / 2;\r\n            func.accept(m, sorted_arr.get(m));\r\n            stack.add(new Pair<>(m+1, curr_segment.b));\r\n            stack.add(new Pair<>(curr_segment.a, m-1));\r\n        }\r\n    }\r\n    \r\n    \r\n    public static <T extends Comparable<T>> void splitter_with_parent(ArrayList<T> sorted_arr, Triconsumer<Integer, T, T> func){\r\n        splitter_with_parent(sorted_arr, func, new Pair<>(0, sorted_arr.size()-1));\r\n    }\r\n    public static <T extends Comparable<T>> void splitter_with_parent(ArrayList<T> sorted_arr, Triconsumer<Integer, T, T> func,\r\n                                                                      Pair<Integer, Integer> segment){\r\n        ArrayList<Triplet<Integer, Integer, Integer>> stack = new ArrayList<>(200);\r\n        int dummy_initial_value = (segment.a + segment.b)/2;\r\n        stack.add(new Triplet<>(segment.a, segment.b, dummy_initial_value));\r\n        \r\n        while (!stack.isEmpty()){\r\n            Triplet<Integer, Integer, Integer> curr_segment = stack.remove(stack.size() - 1);\r\n            \r\n            if (curr_segment.a > curr_segment.b)\r\n                continue;\r\n            \r\n            int m = (curr_segment.a + curr_segment.b) / 2;\r\n            func.accept(m, sorted_arr.get(m), sorted_arr.get(curr_segment.c));\r\n            stack.add(new Triplet<>(m+1, curr_segment.b, m));\r\n            stack.add(new Triplet<>(curr_segment.a, m-1, m));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Pair<T, U>{\r\n    public T a;\r\n    public U b;\r\n    \r\n    public Pair(T item_a, U item_b){\r\n        this.a = item_a;\r\n        this.b = item_b;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"[\" + a + \" \" + b + \"]\";\r\n    }\r\n}\r\n\r\nclass ComparablePair<T extends Comparable<T>, U extends Comparable<U>> extends Pair<T,U>\r\n        implements Comparable<ComparablePair<T, U>>{\r\n    public ComparablePair(T item_a, U item_b) {\r\n        super(item_a, item_b);\r\n    }\r\n    \r\n    @Override\r\n    public int compareTo(ComparablePair<T, U> o) {\r\n        int temp = a.compareTo(o.a);\r\n        if (temp != 0)\r\n            return temp;\r\n        return b.compareTo(o.b);\r\n    }\r\n}\r\n\r\n\r\nclass Triplet<T, U, V>{\r\n    public T a;\r\n    public U b;\r\n    public V c;\r\n    \r\n    public Triplet(T item_a, U item_b, V item_c){\r\n        this.a = item_a;\r\n        this.b = item_b;\r\n        this.c = item_c;\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"[\" + a + \", \" + b + \", \" + c + \"]\";\r\n    }\r\n}\r\n\r\nclass Quadruplet<T, U, V, W>{\r\n    public T a;\r\n    public U b;\r\n    public V c;\r\n    public W d;\r\n    \r\n    \r\n    public Quadruplet(T item_a, U item_b, V item_c, W item_d){\r\n        this.a = item_a;\r\n        this.b = item_b;\r\n        this.c = item_c;\r\n        this.d = item_d;\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"[\" + a + \", \" + b + \", \" + c + \", \" + d + \"]\";\r\n    }\r\n}\r\n\r\n\r\n@SuppressWarnings(\"unchecked\")\r\nclass SenaraiBerantai<T>{\r\n    public HeadBundel<T> head = new HeadBundel<>();\r\n    public TailBundel<T> tail = new TailBundel<>();\r\n    public int length = 0;\r\n    public SenaraiBerantai(){\r\n        head.set_next(tail); head.senarai = this;\r\n        tail.set_prev(head); tail.senarai = this;\r\n    }\r\n    \r\n    public int size() {\r\n        return length;\r\n    }\r\n    public boolean isEmpty() {\r\n        return length == 0;\r\n    }\r\n    public boolean contains(Object o) {\r\n        AbstractBundel<T> current = head.next();\r\n        while (current != tail){\r\n            if (o.equals(\r\n                    ((DataBundel<T>) current).get_data()\r\n            ))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    public T get_first(){\r\n        if (!(head.get_next() instanceof DataBundel))\r\n            return null;\r\n        return ((DataBundel<T>) head.get_next()).get_data();\r\n    }\r\n    public T get_last(){\r\n        if (!(tail.get_prev() instanceof DataBundel))\r\n            return null;\r\n        return ((DataBundel<T>) tail.get_prev()).get_data();\r\n    }\r\n    \r\n    public void add(T item){push_back(item);}\r\n    public DataBundel<T> push_back(T item){\r\n        DataBundel<T> temp = new DataBundel<>(item);\r\n        tail.insert_before_this(temp);\r\n        return temp;\r\n    }\r\n    public DataBundel<T> push_front(T item){\r\n        DataBundel<T> temp = new DataBundel<>(item);\r\n        head.insert_after_this(temp);\r\n        return temp;\r\n    }\r\n    \r\n    public HeadBundel<T> get_head(){return head;}\r\n    public TailBundel<T> get_tail(){return tail;}\r\n    public void extend(SenaraiBerantai<T> other){\r\n        AbstractBundel<T> current = other.get_head().get_next();\r\n        while (current instanceof DataBundel){\r\n            this.push_back(((DataBundel<T>) current).get_data());\r\n            current = current.get_next();\r\n        }\r\n    }\r\n    public void destructive_extend_from(SenaraiBerantai<T> other){\r\n        if (other.length == 0)\r\n            return;\r\n        \r\n        // not necessarily be a data (may be head or tail), but mostly it's data\r\n        AbstractBundel<T> this_first_data  = get_head().get_next();\r\n        AbstractBundel<T> this_last_data   = get_tail().get_prev();\r\n        AbstractBundel<T> other_first_data = other.get_head().get_next();\r\n        AbstractBundel<T> other_last_data  = other.get_tail().get_prev();\r\n        assert (other_first_data instanceof DataBundel);  // karena length > 0\r\n        assert (other_last_data instanceof DataBundel);\r\n        \r\n        \r\n        // this_last_data.set_next(other_first_data)    MUST come before    other_first_data.set_prev(this_last_data)\r\n        // because  this_last_data.set_next()  will set the other_first_data's senarai as this senarai.\r\n        // But if we set the  other_first_data.set_prev()  first, then  other_first_data  will influence its\r\n        // old senarai (`other` object instead of `this`). Therefore it will influence the senarai that will be\r\n        // emptied instead of `this` alive senarai.  The same goes for tail.set_prev() and other_last_data.set_next()\r\n        this_last_data.set_next(other_first_data);\r\n        other_first_data.set_prev(this_last_data);\r\n        tail.set_prev(other_last_data);\r\n        other_last_data.set_next(tail);\r\n        \r\n        other.get_head().set_next(other.get_tail());\r\n        other.get_tail().set_next(other.get_head());\r\n        this.length += other.length;\r\n        other.length = 0;\r\n    }\r\n    public DataBundel<T> get(long i){\r\n        assert i < size();\r\n        AbstractBundel<T> temp = get_head().next;\r\n        for (int j = 0; j < i; j++) {\r\n            temp = temp.next;\r\n        }\r\n        return (DataBundel<T>) temp;\r\n    }\r\n    \r\n    public Object[] toArray(){\r\n        Object[] arr = new Object[length];\r\n        \r\n        int i = 0;\r\n        AbstractBundel<T> current = get_head().get_next();\r\n        while (current instanceof DataBundel){\r\n            arr[i++] = ((DataBundel<T>) current).data;\r\n            current = current.get_next();\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n    public static <T> SenaraiBerantai<T> fromArray(T ... array){\r\n        SenaraiBerantai<T> ret = new SenaraiBerantai<>();\r\n        for (int i = 0; i < array.length; i++) {\r\n            ret.push_back(array[i]);\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    \r\n    public String toString(){return toString(\" \");}\r\n    public String toString(String delimiter){\r\n        StringBuilder string_builder = new StringBuilder(length * 5);\r\n        \r\n        AbstractBundel<T> current = get_head().get_next();\r\n        while (current instanceof DataBundel){\r\n            string_builder.append(((DataBundel<T>) current).data);\r\n            string_builder.append(delimiter);\r\n            current = current.get_next();\r\n        }\r\n        \r\n        return string_builder.toString();\r\n    }\r\n    \r\n    public void forEach(Consumer<DataBundel<T>> consumer){\r\n        AbstractBundel<T> curr = this.head.next;\r\n        while (curr instanceof DataBundel){\r\n            consumer.accept((DataBundel<T>) curr);\r\n            curr = curr.next;\r\n        }\r\n    }\r\n}\r\n\r\nabstract class AbstractBundel<T>{\r\n    protected SenaraiBerantai<T> senarai;\r\n    protected AbstractBundel<T> next;\r\n    protected AbstractBundel<T> prev;\r\n    \r\n    protected void increase_senarai_berantai_length(int by){\r\n        senarai.length += by;\r\n        if (senarai.length < 0)\r\n            throw new RuntimeException();\r\n    }\r\n    public abstract void set_senarai(SenaraiBerantai<T> new_senarai);\r\n    protected void set_next(AbstractBundel<T> bundel){\r\n        bundel.set_senarai(this.senarai); next = bundel;\r\n    }\r\n    \r\n    public AbstractBundel<T> get_next(){\r\n        return next();\r\n    }\r\n    \r\n    protected void set_prev(AbstractBundel<T> bundel){\r\n        bundel.set_senarai(this.senarai); prev = bundel;\r\n    }\r\n    \r\n    public AbstractBundel<T> get_prev(){\r\n        return prev();\r\n    }\r\n    \r\n    public boolean insert_after_this(AbstractBundel<T> bundel){\r\n        if (bundel.prev != null || bundel.next != null || bundel.senarai != null)\r\n            throw new IllegalStateException();\r\n        \r\n        bundel.senarai = senarai;\r\n        AbstractBundel<T> prev_before = get_prev();\r\n        AbstractBundel<T> next_before = get_next();\r\n        \r\n        set_next(bundel);\r\n        bundel.set_prev(this);\r\n        bundel.set_next(next_before);\r\n        \r\n        // if (next_before != null)\r\n        next_before.set_prev(bundel);\r\n        increase_senarai_berantai_length(1);\r\n        return true;\r\n    }\r\n    \r\n    public boolean insert_before_this(AbstractBundel<T> bundel){\r\n        if (bundel.prev != null || bundel.next != null || bundel.senarai != null)\r\n            throw new IllegalStateException();\r\n        \r\n        bundel.senarai = senarai;\r\n        AbstractBundel<T> prev_before = prev;\r\n        AbstractBundel<T> next_before = next;\r\n        \r\n        set_prev(bundel);\r\n        bundel.set_next(this);\r\n        bundel.set_prev(prev_before);\r\n        // if (prev_before != null)\r\n        prev_before.set_next(bundel);\r\n        increase_senarai_berantai_length(1);\r\n        return true;\r\n    }\r\n    \r\n    public boolean hasNext(){\r\n        return next != null;\r\n    }\r\n    public boolean hasPrevious(){return prev != null; }\r\n    public AbstractBundel<T> next(){ next.set_senarai(this.senarai); return next; }\r\n    public AbstractBundel<T> prev(){ prev.set_senarai(this.senarai); return prev; }\r\n    public AbstractBundel<T> previous(){ return prev(); }\r\n    \r\n}\r\nabstract class SpecializedBundel<T> extends AbstractBundel<T> {}\r\nabstract class SpecializedHeadTailBundel<T> extends SpecializedBundel<T>{\r\n    public void set_senarai(SenaraiBerantai<T> new_senarai){  // do nothing\r\n    }\r\n}\r\nclass HeadBundel<T> extends SpecializedHeadTailBundel<T>{\r\n    @Override\r\n    public void set_prev(AbstractBundel<T> bundel) {  // do nothing\r\n    }\r\n    @Override\r\n    public AbstractBundel<T> get_prev() {\r\n        return null;\r\n    }\r\n    @Override\r\n    public boolean insert_before_this(AbstractBundel<T> bundel) {\r\n        return false;\r\n    }\r\n}\r\nclass TailBundel<T> extends SpecializedHeadTailBundel<T>{\r\n    @Override\r\n    public void set_next(AbstractBundel<T> bundel) {  // do nothing\r\n    }\r\n    @Override\r\n    public AbstractBundel<T> get_next() {\r\n        return null;\r\n    }\r\n    @Override\r\n    public boolean insert_after_this(AbstractBundel<T> bundel) {\r\n        return false;\r\n    }\r\n}\r\nclass DataBundel<T> extends AbstractBundel<T>{\r\n    T data;\r\n    \r\n    public DataBundel(T data) {\r\n        super();\r\n        this.data = data;\r\n    }\r\n    public void set_senarai(SenaraiBerantai<T> new_senarai){\r\n        senarai = new_senarai;\r\n    }\r\n    public void set_data(T new_data){\r\n        data = new_data;\r\n    }\r\n    public T get_data(){\r\n        return data;\r\n    }\r\n    public T remove(){\r\n        T ret = data;\r\n        \r\n        AbstractBundel<T> prev = this.get_prev();\r\n        AbstractBundel<T> next = this.get_next();\r\n        prev.set_next(next);\r\n        next.set_prev(prev);\r\n        increase_senarai_berantai_length(-1);\r\n        \r\n        this.next = null;\r\n        this.prev = null;\r\n        this.data = null;\r\n        return ret;\r\n    }\r\n    \r\n    public boolean has_next_data() {\r\n        return get_next() instanceof DataBundel;\r\n    }\r\n}\r\n\r\n@FunctionalInterface\r\ninterface Triconsumer<T, U, V>{\r\n    void accept(T item1, U item2, V item3);\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Solusi/src/Solusi.java b/Solusi/src/Solusi.java
--- a/Solusi/src/Solusi.java	(revision 25bacc2485b38c8a56236b1eb559952a0a5c5eb3)
+++ b/Solusi/src/Solusi.java	(date 1636429949107)
@@ -130,7 +130,7 @@
             pulau_hm.put(nama_pulau, pulau);
             kuil_hm.put(nama_pulau, kuil);
         }
-        debug_print_semua_kuil();
+//        debug_print_semua_kuil();
     }
     
     public static void input_informasi_raiden(){
